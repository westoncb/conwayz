<!DOCTYPE html>
<html lang="en">
  <script id="fragment_shader" type="x-shader/x-fragment">
      precision highp float;
      uniform vec2 iResolution;
      uniform vec3 cameraPos;
      uniform vec3 cameraDir;
      uniform float stepCompletion;
      const float row_size = 256.0;
      const float col_size = 256.0;
      const float EPS = 0.01;
      const float OFFSET = EPS * 100.0;
      const float bevel = 0.8;
      const vec3 lightDir = vec3( -0.48666426339228763, 0.8111071056538127, -0.3244428422615251 );
      const vec3 box = vec3(3., 0.75, 3.);
      const float CELL_WIDTH = 10.0;
      uniform sampler2D tex;
      bool cellDying = false;
      bool cellBorn = false;

      const vec3 FACE_COLOR = vec3(.9,.9,1.);
      const vec3 BACKGROUND_COLOR = vec3(.01, .02, .05);

      struct Model {
        float dist;
        vec3 albedo;
        float glow;
      };

      vec3 doLighting(Model model, vec3 pos, vec3 nor, vec3 ref, vec3 rd) {
        vec3 lightPos = normalize(vec3(0, 10, 5));
        vec3 backLightPos = normalize(vec3(5,3,1));
        vec3 ambientPos = vec3(0,1,0);
        
        vec3  lig = lightPos;
        float amb = clamp((dot(nor, ambientPos) + 1.) / 2., 0., 1.);
        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );
        float bac = pow(clamp(dot(nor, backLightPos), 0., 1.), 1.5);
        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );
        
        vec3 lin = vec3(0.0);

        if (cellBorn) {
          float redAndBlue = stepCompletion*.9;
          lin += 1.60 * dif * vec3(redAndBlue, 1., redAndBlue);
        } else if (cellDying) {
          float greenAndBlue = .9 - min(stepCompletion*.9, .9);
          lin += 1.60 * dif * vec3(greenAndBlue, greenAndBlue, greenAndBlue);
        } else {
          lin += 1.60 * dif * vec3(.9);
        }

        lin += 0.20 * amb * vec3(.3, .5, .7);
        // lin += 0.30 * bac * vec3(.25);
        lin += 0.20 * fre * vec3(1);
        
        vec3 albedo = model.albedo;
        vec3 col = mix(albedo * lin, albedo, model.glow);    

        return col;
      }


      // --------------------------------------------------------
      // Ray Marching
      // Adapted from cabbibo https://www.shadertoy.com/view/Xl2XWt
      // --------------------------------------------------------

      const float MAX_TRACE_DISTANCE = 20000.; // max trace distance
      const float INTERSECTION_PRECISION = .001; // precision of the intersection
      const int NUM_OF_TRACE_STEPS = 100;
      const float FUDGE_FACTOR = .9; // Default is 1, reduce to fix overshoots

      struct CastRay {
        vec3 origin;
        vec3 direction;
      };

      struct Ray {
        vec3 origin;
        vec3 direction;
        float len;
      };

      struct Hit {
        Ray ray;
        Model model;
        vec3 pos;
        bool isBackground;
        vec3 normal;
        vec3 color;
      };

      // Repeat only a few times: from indices <start> to <stop> (similar to above, but more flexible)
      float pModInterval1(inout float p, float size, float start, float stop) {
        float halfsize = size*0.5;
        float c = floor((p + halfsize)/size);
        p = mod(p+halfsize, size) - halfsize;
        if (c > stop) { //yes, this might not be the best thing numerically.
          p += size*(c - stop);
          c = stop;
        }
        if (c <start) {
          p += size*(c - start);
          c = start;
        }
        return c;
      }

      // Repeat in two dimensions
      vec2 pMod2(inout vec2 p, vec2 size) {
        vec2 c = floor((p + size*0.5)/size);
        p = mod(p + size*0.5,size) - size*0.5;
        return c;
      }

      Model roundBox( vec3 p, vec3 dimensions, float radius )
      {
        vec2 index = pMod2(p.xz, vec2(CELL_WIDTH, CELL_WIDTH));

        float r = 0.35;
        float g = 0.35;
        float b = 0.35;

        index.x /= row_size;
        index.y /= col_size;

        //In order to center the grid in our viewport
        index -= 0.5;

        vec4 cellData = texture2D(tex, index);

        cellDying = cellData.z == 1. && cellData.x == 0.;
        cellBorn = cellData.z == 1. && cellData.x == 1.;

        // p.y += (1.0-cellData.y)*2.0;
        float scaleFactor = cellData.y;

        //cellData.z will be a zero if it has been more than one turn since the
        //cell's life/death state changed. cellData.x holds a one when the cell
        //is alive, a zero when dead. Using it as the scaleFactor ensures that
        //the cell will be at full or zero size when an animation finishes.
        if (cellData.z == 0.) {
          scaleFactor = cellData.x;
        }

        dimensions.xyz *= scaleFactor;
        radius *= scaleFactor;

        dimensions.xz = step(0.1, dimensions.xz)*dimensions.x;

        pMod2(p.xz, vec2(CELL_WIDTH, CELL_WIDTH));
        float d = length(max(abs(p)-dimensions,0.0))-radius;

        vec3 albedo = vec3(r, g, b);

        if (cellBorn) {
          albedo = vec3(r*(scaleFactor), g, b*(scaleFactor));
        } else if (cellDying) {
          albedo = vec3(r*scaleFactor, g*scaleFactor, b*scaleFactor);
        }

        return Model(d, albedo, .1);
      }

      // Plane with normal n (n is normalized) at some distance from the origin
      float fPlane(vec3 p, vec3 n, float distanceFromOrigin) {
        return dot(p, n) + distanceFromOrigin;
      }

      vec3 calcNormal( in vec3 pos ){
        vec3 eps = vec3( 0.001, 0.0, 0.0 );
        vec3 nor = vec3(
            roundBox(pos+eps.xyy, box, bevel).dist - roundBox(pos-eps.xyy, box, bevel).dist,
            roundBox(pos+eps.yxy, box, bevel).dist - roundBox(pos-eps.yxy, box, bevel).dist,
            roundBox(pos+eps.yyx, box, bevel).dist - roundBox(pos-eps.yyx, box, bevel).dist );
        return normalize(nor);
      }

      float fOpUnionRound(float a, float b, float r) {
        vec2 u = max(vec2(r - a,r - b), vec2(0.0));
        return max(r, min (a, b)) - length(u);
      }

      float fOpUnionSoft(float a, float b, float r) {
        float e = max(r - abs(a - b), 0.0);
        return min(a, b) - e*e*0.25/r;
      }

      // The "Chamfer" flavour makes a 45-degree chamfered edge (the diagonal of a square of size <r>):
      float fOpUnionChamfer(float a, float b, float r) {
        return min(min(a, b), (a - r + b)*sqrt(0.5));
      }

          
      Hit raymarch(CastRay castRay){

        float currentDist = INTERSECTION_PRECISION * 2.0;
        Model boxModel;
        Model planeModel;
        Model model;

        // camera and ray
        vec3 cPos  = cameraPos;
        vec3 cDir  = cameraDir;
        vec3 cSide = normalize( cross( cDir, vec3( 0.0, 1.0 ,0.0 ) ) );
        vec3 cUp   = normalize( cross( cSide, cDir ) );
        float targetDepth = 1.3;
        
        Ray ray = Ray(castRay.origin, castRay.direction, 0.);

        for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){
          if (currentDist < INTERSECTION_PRECISION || ray.len > MAX_TRACE_DISTANCE) {
              break;
          }

          vec3 rayVec = ray.origin + ray.direction * ray.len;
          boxModel = roundBox(rayVec, box, bevel);
          planeModel = Model(fPlane(rayVec, vec3(0.0, 1.0, 0.0), 1.0), vec3(0.4, 0.5, 0.6), 0.12);

          model = boxModel;
          if (planeModel.dist < boxModel.dist) {
            model = planeModel;
          }

          currentDist = fOpUnionSoft(boxModel.dist, planeModel.dist, 0.01);
          ray.len += currentDist * FUDGE_FACTOR;
        }
        
        bool isBackground = false;
        vec3 pos = vec3(0);
        vec3 normal = vec3(0);
        vec3 color = vec3(0);
        
        if (ray.len > MAX_TRACE_DISTANCE) {
          isBackground = true;
        } else {
          pos = ray.origin + ray.direction * ray.len;
          normal = calcNormal(pos);

          if (planeModel.dist <= boxModel.dist) {
            // normal = vec3(0, 1, 0);
            float test = abs(pos.x);
            pModInterval1(test, CELL_WIDTH, 0.0, 50000.0);
            test = step(4.0, test);
            test = 1.0 - test;

            float test2 = abs(pos.z);
            pModInterval1(test2, CELL_WIDTH, 0.0, 50000.0);
            test2 = step(4.0, test2);
            test2 = 1.0 - test2;
            float intensity = test*test2/2.;
            // intensity = 1.0;
            model.albedo.x = intensity*0.2;
            model.albedo.y = intensity*0.3;
            model.albedo.z = intensity*0.5;
          }
        }

        return Hit(ray, model, pos, isBackground, normal, color);
      }


      // --------------------------------------------------------
      // Rendering
      // --------------------------------------------------------

      void shadeSurface(inout Hit hit){
          
        vec3 color = BACKGROUND_COLOR;
        
        if (hit.isBackground) {
          hit.color = color;
          return;
        }

        vec3 ref = reflect(hit.ray.direction, hit.normal);

        #ifdef DEBUG
          color = hit.normal * 0.5 + 0.5;
        #else 
          color = doLighting(
            hit.model,
            hit.pos,
            hit.normal,
            ref,
            hit.ray.direction
          );
        #endif

        hit.color = color;
      }

      vec3 render(Hit hit){
          shadeSurface(hit);
        return hit.color;
      }

      // --------------------------------------------------------
      // Gamma
      // https://www.shadertoy.com/view/Xds3zN
      // --------------------------------------------------------

      const float GAMMA = 2.2;

      vec3 gamma(vec3 color, float g) {
          return pow(color, vec3(g));
      }

      vec3 linearToScreen(vec3 linearRGB) {
          return gamma(linearRGB, 1.0 / GAMMA);
      }

      void main()
      {
          vec2 p = (-iResolution.xy + 2.0*gl_FragCoord.xy)/iResolution.y;

          vec3 camTar = vec3( 0. , 0. , 0. );
          float camRoll = 0.;
          

          
          // create view ray
          vec3 rd = normalize( vec3(p.xy,2.0) ); // 2.0 is the lens length

          // camera and ray
          vec3 cPos  = cameraPos;
          vec3 cDir  = cameraDir;
          vec3 cSide = normalize( cross( cDir, vec3( 0.0, 1.0 ,0.0 ) ) );
          vec3 cUp   = normalize( cross( cSide, cDir ) );
          float targetDepth = 1.3;
          rd = normalize( cSide * p.x + cUp * p.y + cDir * targetDepth );
          
          Hit hit = raymarch(CastRay(cPos, rd));

          vec3 color = render(hit);
          color = linearToScreen(color);

          gl_FragColor = vec4(color,1.0);
      }
    </script>

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link href="https://fonts.googleapis.com/css?family=Sahitya" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Open+Sans:400,700" rel="stylesheet">
    <link rel="stylesheet" href="style.css" type="text/css">
  </head>
  <body>

    <span class='title'><span class='big-c'>C</span>onwayz</span><span class='subtitle'>—"The vital, Conwaysian cellular automaton we all know and love."</span>
    <div class='main-container'>
      <div class='left-column side-column'>
        <div class='controls-section column-section'>
          <span class='minor-title'>Controls</span>
          <span class='controls-text'>
            <div class='controls-subsection'>
              <span class='bolded'>Zoom:</span>
              Mouse wheel or trackpad.
            </div>
            
            <div class='controls-subsection'>
              <span class='bolded'>Pan:</span>
              Right click and drag.
            </div>

            <div class='controls-subsection'>
              <span class='bolded'>Tilt camera:</span>
              Left click and drag.
            </div>
          </span>
        </div>
        <hr>
        <div class='about-section column-section'>
          <span class='minor-title about-title'>About</span>
          <span class='about-text'>
            This program was created by <a href="http://westoncb.com">Weston Beecroft</a> mostly as a way to experiment
            with using <a href='http://9bitscience.blogspot.com/2013/07/raymarching-distance-fields_14.html'>raymarching</a> to do something practical. It has a pretty minimal feature set at the moment, but I may add to it in the near feature. You can contact me at <i>westoncb at Google's mail service</i>. The source is <a href='https://github.com/westoncb/conwayz'>available on Github</a>.
          </span>
        </div>
      </div>
      <div class='center-column'>
        <canvas id='canvas'></canvas>
        <div class='control-bar'></div>
      </div>
      <div class='right-column side-column'>
        <hr>
        <div class='config-description'>
          <p class='config-title minor-title'>No pattern selected</p>
          <p class='config-description-body'></p>
        </div>
      </div>
      
    </div>
    

    <script src="lib/three.js"></script>
    <script src="lib/OrbitControls.js"></script>

    <script src="lib/stats.min.js"></script>
    <script src="lib/jquery-2.2.1.min.js"></script>

    <!-- Boostrap CSS -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">

    <!-- Bootstrap JavaScript -->
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
    

    <script id="vertex_shader" type="x-shader/x-vertex">
      attribute vec3 position;
      void main(void) {
        gl_Position = vec4(position, 1.0);
      }
    </script>
  

    <script>
      var camera, dummyCamera, scene, controls, renderer;
      var geometry, material, mesh;
      var mouse = new THREE.Vector2( 0.5, 0.5 );
      var canvas;
      var stats;
      var clock = new THREE.Clock();
      var texture;
      var gl;
      var ROW_SIZE = 256;
      var COL_SIZE = 256;

      //A three dimensional array. Holds an array of 'row' arrays, each
      //element of which is a four component array carrying data for a
      //particular cell in the grid. The four components are:
      // 0) A one or zero indicating whether the cell is live or dead.
      // 1) A scale factor for resize animations during death/birth.
      // 2) A one if the cell's life/death state changed this turn; otherwise a one.
      // 3) Unused at the moment.
      var grid = [];

      var toggledCells = [];
      var timeSinceGameUpdate = 0;
      var stepTime = 500;
      var stepCompletion = 0;
      var configFileList = [];

      init();
      update();

      function init() {
        setupConfigFileDropdown();


        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera();
        dummyCamera = new THREE.Camera();
        camera.position.set(0, 291.5, 0);
        camera.lookAt( new THREE.Vector3( 0, 0, 0 ) );
        geometry = new THREE.PlaneBufferGeometry( 2.0, 2.0 );
        canvas = document.getElementById("canvas");
        renderer = new THREE.WebGLRenderer({ canvas: canvas });
        renderer.setPixelRatio( window.devicePixelRatio );
        gl = renderer.getContext();


        var theOffsets = new Float32Array(ROW_SIZE*COL_SIZE*4);
        texture = textureFromFloats(gl, ROW_SIZE, COL_SIZE, theOffsets);
        texture.needsUpdate = true;

        initGrid();

        material = new THREE.RawShaderMaterial( {
          uniforms: {
            iResolution: { value: new THREE.Vector2( canvas.width, canvas.height ) },
            cameraPos:  { value: camera.getWorldPosition() },
            cameraDir:  { value: camera.getWorldDirection() },
            offsets: {type: "fv", value: theOffsets},
            tex: {type: "t", value: texture},
            stepCompletion: {value: stepCompletion}
          },
          vertexShader: document.getElementById( 'vertex_shader' ).textContent,
          fragmentShader: document.getElementById( 'fragment_shader' ).textContent
        } );

        mesh = new THREE.Mesh( geometry, material );
        scene.add( mesh );
        canvas.addEventListener( 'mousemove', onMouseMove );
        window.addEventListener( 'resize', onWindowResize );
        // document.body.appendChild( canvas );
        controls = new THREE.OrbitControls( camera, canvas );
        controls.enableZoom = true;
        stats = new Stats();
        // document.body.appendChild( stats.dom );

        onWindowResize();
      }

      function textureFromFloats(gl,width,height,float32Array) 
      {
        return new THREE.DataTexture(float32Array, width, height, THREE.RGBA, THREE.FloatType, THREE.UVMapping, THREE.RepeatWrapping, THREE.RepeatWrapping, THREE.NearestFilter, THREE.NearestFilter, 1);
      }

      function initGrid() {
        var configGrid = [];

        //Fill the config grid with random live and dead cells
        for (var i = 0; i < COL_SIZE; i++) {

          var row = [];
          for (var j = 0; j < ROW_SIZE; j++) {

            var val = Math.random();
            if (val < .61803) {
              val = 1;
            } else {
              val = 0;
            }

            row[j] = val;
          }

          configGrid[i] = row;
        }

        copyConfigGridIntoGrid(ROW_SIZE, COL_SIZE, configGrid, grid);
      }

      function stepConwaysGame(grid) {
        clearRecentlyToggledIndicators();
        toggledCells.length = 0;

        for (var i = 0; i < COL_SIZE; i++) {
          for (var j = 0; j < ROW_SIZE; j++) {

            var oldState = grid[i][j][0];
            var alive = oldState === 1;
            var neighborCount = liveNeighborCount(grid, i, j);

            var newState = newCellState(alive, neighborCount);
            
            //We don't immediately toggle cells because it would effect the application
            //of rules to other cells during this step of the game.
            if (newState !== oldState) {
              toggledCells.push(i);
              toggledCells.push(j);
            }
          }
        }

        //Actually toggle any cells that should be toggled now
        for (var i = 0; i < toggledCells.length; i+=2) {
          var row = toggledCells[i];
          var col = toggledCells[i+1];
          var cell = grid[row][col];

          if (cell[0] === 1) {
            newState = 0;
          } else {
            newState = 1;
          }
          cell[0] = newState;
          cell[2] = 1; //Indicates that its state changed this turn
        }
      }

      function newCellState(alive, neighborCount) {
        if (alive && neighborCount < 2) {
          return 0;
        } else if (alive && (neighborCount === 2 || neighborCount === 3)) {
          return 1;
        } else if (alive && neighborCount > 3) {
          return 0;
        } else if (!alive && neighborCount === 3) {
          return 1;
        } else {
          return 0;
        }
      }

      function liveNeighborCount(grid, row, col) {
        var leftNeighbor = 0;
        var rightNeighbor = 0;
        var topNeighbor = 0;
        var bottomNeighbor = 0;
        var ulNeighbor = 0;
        var llNeighbor = 0;
        var urNeighbor = 0;
        var lrNeighbor = 0;

        if (col > 0) {
          leftNeighbor = grid[row][col-1][0];
        }
        if (col < ROW_SIZE-1) {
          rightNeighbor = grid[row][col+1][0];
        }
        if (row > 0) {
          bottomNeighbor = grid[row-1][col][0];
        }
        if (row < COL_SIZE-1) {
          topNeighbor = grid[row+1][col][0];
        }
        if (row < COL_SIZE-1 && col > 0) {
          ulNeighbor = grid[row+1][col-1][0]; 
        }
        if (row > 0 && col > 0) {
          llNeighbor = grid[row-1][col-1][0]; 
        }
        if (row < COL_SIZE-1 && col < ROW_SIZE-1) {
          urNeighbor = grid[row+1][col+1][0]; 
        }
        if (row > 0 && col < ROW_SIZE-1) {
          lrNeighbor = grid[row-1][col+1][0]; 
        }

        return leftNeighbor + rightNeighbor + topNeighbor + bottomNeighbor +
               ulNeighbor + llNeighbor + urNeighbor + lrNeighbor;
      }

      function updateDataTextureFromGrid(grid) {
        var vectorCount = texture.image.data.length / 4;
        for (var i = 0; i < texture.image.data.length; i+=4) {

          //Each cell in the grid has four floats of data in the texture
          var cellIndex = i/4;
          var row = Math.floor(cellIndex / ROW_SIZE);
          var col = cellIndex % ROW_SIZE;
          texture.image.data[i] = grid[row][col][0];
          texture.image.data[i+1] = grid[row][col][1];
          texture.image.data[i+2] = grid[row][col][2];
          texture.image.data[i+3] = grid[row][col][3];
        }
        texture.needsUpdate = true;
      }

      function clearRecentlyToggledIndicators() {
        for (var i = 0; i < toggledCells.length; i+= 2) {
          var row = toggledCells[i];
          var col = toggledCells[i+1];

          grid[row][col][2] = 0;
        }
      }

      function sinEase(t, start, end) {
        return -(end-start)/2 * (Math.cos(Math.PI*t) - 1) + start;
      }

      function update(timestamp) {
        stats.begin();

        var delta = clock.getDelta();
        var deltaMillis = delta*1000;
        
        updateGame(deltaMillis);
        

        controls.update( delta );
        if ( camera.position.y < 0 ) camera.position.y = 0;
        material.uniforms.iResolution.value = new THREE.Vector2( canvas.width, canvas.height );
        material.uniforms.cameraPos.value = camera.getWorldPosition();
        material.uniforms.cameraDir.value = camera.getWorldDirection();
        material.uniforms.stepCompletion.value = stepCompletion;

        render (delta)
      }

      function updateGame(deltaMillis) {
        timeSinceGameUpdate += deltaMillis;

        if (timeSinceGameUpdate > stepTime) {
          stepConwaysGame(grid);
          timeSinceGameUpdate = 0;
        }

        stepCompletion = sinEase(timeSinceGameUpdate / stepTime, 0, 1);

        updateDataTextureFromGrid(grid);

        if (toggledCells !== undefined) {
          for (var i = 0; i < toggledCells.length; i+= 2) {
            var row = toggledCells[i];
            var col = toggledCells[i+1];

            var target = grid[row][col][0];
            var initial = target === 1 ? 0 : 1;
            var completionRatio = (timeSinceGameUpdate / stepTime);
            grid[row][col][1] = initial + (target - initial)*stepCompletion;

            grid[row][col][2] = 1;
          }
        }
      }

      function setupConfigFileDropdown() {
        $.ajax({
          //This will retrieve the contents of the folder if the folder is configured as 'browsable'
          url: './configs/other',
          success: function (data) {
            $(data).find("a:contains(" + ".l" + ")").each(function() {
                configFileList.push($(this).attr('href'));
            });

            var dropdownContainer = $('.right-column');
            var dropdown = $('<div class="dropdown"></div>');
            var menu = $('<ul class="dropdown-menu"></ul>');
            var index = 0;
            configFileList.forEach(function(path) {
              var fileName = fileNameOnly(path);
              menu.append('<li><a href="#" class="menu-item" id='+ index +'>' + fileName + '</a></li>');
              index++;
            });

            dropdown.append('<button class="configs-btn btn btn-primary dropdown-toggle" type="button" data-' +
              'toggle="dropdown">Patterns <span class="caret"></span></button>');
            dropdown.append(menu);
            dropdownContainer.prepend(dropdown);

            $('.menu-item').click(function(e) {
              var index = Number(e.target.id);
              var path = configFileList[index];
              readTextFile(path, loadNewConwaysConfig);
              $('.config-title').text(fileNameOnly(path));
            });
          }
        });
      }

      function fileNameOnly(path) {
        return path.substring(path.lastIndexOf('/')+1);
      }

      function loadNewConwaysConfig(text) {
        var result = parseConwaysConfig(text);

        var comments = result[0];
        var dimensions = result[1];
        var configGrid = result[2];

        var configWidth = dimensions[0];
        var configHeight = dimensions[1];

        copyConfigGridIntoGrid(configWidth, configHeight, configGrid, grid);

        displayComments(comments);
      }

      function displayComments(comments) {
        var commentText = "";

        comments.forEach(function(comment, i) {
          var prefix = '';
          if (i !== 0) {
            prefix = '<br>'
          }
          commentText += prefix + comment.substring(2);
        });

        $('.config-description-body').html(commentText);
      }

      function copyConfigGridIntoGrid(configWidth, configHeight, configGrid, grid) {
        //Used to center the config grid over our grid (since they may be different sizes)
        var xOffset = Math.floor((ROW_SIZE - configWidth)/2);
        var yOffset = Math.floor((COL_SIZE - configHeight)/2);

        for (var i = 0; i < COL_SIZE; i++) {
          var row = [];

          var configRowIndex = i - yOffset;
          var configRow = null;

          if (configRowIndex >= 0 && configRowIndex < configHeight) {
            configRow = configGrid[configRowIndex];
          }

          for (var j = 0; j < ROW_SIZE; j++) {

            var configIndex = j - xOffset;
            var val = 0;

            if (configRow != null && configIndex >= 0 && configIndex < configWidth) {
              val = configRow[configIndex];
            }

            //Each cell in the grid holds an arry of data.
            row[j] = [val,val,0,0];
          }

          grid[i] = row;
        }

        updateDataTextureFromGrid(grid);
      }

      //This is for 'dbLife (*.L)' files, as described here: http://psoup.math.wisc.edu/mcell/ca_files_formats.html
      function parseConwaysConfig(text) {
        var lines = text.match(/[^\r\n]+/g);
        var comments = [];
        var dimensions = [];
        var gridText = "";
        var gridData;
        
        lines.forEach(function(line) {
          if (line.startsWith('#')) { //comments
            comments.push(line);
          } else if (line.toLowerCase().startsWith("x")) { //dimensions

            var noWhiteSpaceLine = line.replace(/\s/g,'');
            var xAndY = noWhiteSpaceLine.split(",");
            var x = xAndY[0].split("=")[1];
            var y = xAndY[1].split("=")[1];
            dimensions.push(Number(x));
            dimensions.push(Number(y));

          } else { //grid data (actual info about whether cells are live or dead)
            gridText += line;
          }
        });

        gridData = parseGridText(gridText, dimensions);

        return [comments, dimensions, gridData];
      }

      function parseGridText(text, dimensions) {
        var rows = text.split("$");
        var width = dimensions[0];
        var height = dimensions[1];
        var grid = new Array(height);
        for (var i = 0; i < grid.length; i++) {
          grid[i] = new Array(width);
        }

        rows.forEach(function(row, j) {
          var inNumChunk = false;
          var inBOChunk = false;
          var numChunk = "";
          var boChunk = "";
          var chunks = [];

          for (var i = 0; i < row.length; i++) {
            var char = row[i];

            if (char === 'o' || char === 'b') { //Live cell or dead cell
              if (inBOChunk) {
                boChunk += char;
              } else {
                boChunk = char;
              }

              inBOChunk = true;

              if (inNumChunk) {
                chunks.push(Number(numChunk));
                inNumChunk = false;
              }

              if (i === row.length-1 || row[i+1] === "!") {
                chunks.push(boChunk);
              }
            } else if (!isNaN(char)) { //It's a number

              if (inNumChunk) {
                numChunk += char;
              } else {
                numChunk = char;
              }

              inNumChunk = true;

              if (inBOChunk) {
                chunks.push(boChunk);
                inBOChunk = false;
              }

              if (i === row.length-1 || row[i+1] === "!") {
                chunks.push(numChunk);
              }
            } else if (char !== "!") { // "!" indicates the end of the data
              console.log("ERROR: unexpected character in config file grid data.");
            }
          }

          fillRow(grid[j], chunks, width);
          
        });

        
        //Add empty rows for the difference between specified
        //grid height and the actual data provided
        for (var i = rows.length; i < height; i++) {
          fillRow(grid[i], [], width);
        }

        return grid;
      }

      function fillRow(row, chunks, rowSize) {
        var rowIndex = 0;
        var tagCount = 1;

        chunks.forEach(function(chunk) {

          if (!isNaN(chunk)) { //It's a number
            tagCount = chunk;
          } else {
            for (var i = 0; i < chunk.length; i++) {
              var char = chunk.charAt(i);

              //Convert b and o to 0 and 1
              if (char === 'b') {
                char = 0;
              } else if (char === 'o') {
                char = 1;
              }

              if (i === 0) {
                for (var j = 0; j < tagCount; j++) {
                  row[rowIndex] = char;
                  rowIndex++;
                }
              } else {
                row[rowIndex] = char;
                rowIndex++;
              }
            }
            tagCount = 1;
          }
        });

        //Fill in the ends of rows with zeros
        for (var i = rowIndex; i < rowSize; i++) {
          row[i] = 0;
        }
      }

      function readTextFile(file, completion)
      {
        var rawFile = new XMLHttpRequest();
        rawFile.open("GET", file, true);
        rawFile.onreadystatechange = function ()
        {
          if(rawFile.readyState === 4)
          {
            if(rawFile.status === 200 || rawFile.status == 0)
            {
              var allText = rawFile.responseText;

              completion(allText);
            }
          }
        }
        rawFile.send(null);
      }

      function render(delta) {
        renderer.render( scene, dummyCamera );
        stats.end();
        requestAnimationFrame( update );
      }

      function onMouseMove( e ) {
        mouse.x = e.offsetX / canvas.width;
        mouse.y = e.offsetY / canvas.height;
      }

      var timeoutEvent;

      function onWindowResize( e) {
        doResize();

        clearTimeout(timeoutEvent);
        timeoutEvent = setTimeout(doResize, 500);
      }

      function doResize() {
        var win = $(window);
        var centerColumn = $('.center-column');
        var canvas = $('#canvas');
        var controlBar = $('.control-bar');

        var controlBarHeight = 40;
        var freeVerticalSpace = 120;
        var columnHeight = win.height() - freeVerticalSpace;
        var width = centerColumn.width();
        var canvasHeight = columnHeight - controlBarHeight;

        centerColumn.css('height', columnHeight);
        canvas.css('height', canvasHeight)
        controlBar.css('height', controlBarHeight);
        controlBar.css('width', width);

        //There is more complexity in this resize function than it seems like
        //needs to be, because this 'setSize' function must be called in order to
        //update properties of the threejs renderer—but it also updates the canvas
        //component size (which we would prefer to be resized automatically through CSS).
        //Flexbox is resizing the canvas' container, and we want the width of the canvas
        //to match the container width—but there is some timing issue or something with
        //retreiving the width (which is why we use a delay in 'onWindowResize'). The most
        //this has done is mitigate the issue; the layout remains imperfect.
        renderer.setSize(width, canvasHeight);
      }
    </script>

  </body>
</html>