<!DOCTYPE html>
<html lang="en">
  <script id="fragment_shader" type="x-shader/x-fragment">
      precision highp float;
      uniform vec2 iResolution;
      uniform vec3 cameraPos;
      uniform vec3 cameraDir;
      const float EPS = 0.01;
      const float OFFSET = EPS * 100.0;
      const float bevel = 0.8;
      const vec3 lightDir = vec3( -0.48666426339228763, 0.8111071056538127, -0.3244428422615251 );
      const vec3 box = vec3(1.7, 1, 1.7);
      uniform sampler2D tex;



      const vec3 FACE_COLOR = vec3(.9,.9,1.);
      const vec3 BACK_COLOR = vec3(.1,.1,.15);
      const vec3 BACKGROUND_COLOR = vec3(.0, .005, .03);

      struct Model {
        float dist;
        vec3 albedo;
        float glow;
      };

      vec3 doLighting(Model model, vec3 pos, vec3 nor, vec3 ref, vec3 rd) {
        vec3 lightPos = normalize(vec3(-1, 20, 10));
        vec3 backLightPos = normalize(vec3(5,3,1));
        vec3 ambientPos = vec3(0,1,0);
        
        vec3  lig = lightPos;
        float amb = clamp((dot(nor, ambientPos) + 1.) / 2., 0., 1.);
        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );
        float bac = pow(clamp(dot(nor, backLightPos), 0., 1.), 1.5);
        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );
        
        vec3 lin = vec3(0.0);
        lin += 1.20 * dif * vec3(.9);
        lin += 0.80 * amb * vec3(.5, .7, .8);
        lin += 0.30 * bac * vec3(.25);
        lin += 0.20 * fre * vec3(1);
        
        vec3 albedo = model.albedo;
        vec3 col = mix(albedo * lin, albedo, model.glow);    

        return col;
      }


      // --------------------------------------------------------
      // Ray Marching
      // Adapted from cabbibo https://www.shadertoy.com/view/Xl2XWt
      // --------------------------------------------------------

      const float MAX_TRACE_DISTANCE = 600.; // max trace distance
      const float INTERSECTION_PRECISION = .001; // precision of the intersection
      const int NUM_OF_TRACE_STEPS = 100;
      const float FUDGE_FACTOR = .9; // Default is 1, reduce to fix overshoots

      struct CastRay {
        vec3 origin;
        vec3 direction;
      };

      struct Ray {
        vec3 origin;
        vec3 direction;
        float len;
      };

      struct Hit {
        Ray ray;
        Model model;
        vec3 pos;
        bool isBackground;
        vec3 normal;
        vec3 color;
      };

      // Repeat only a few times: from indices <start> to <stop> (similar to above, but more flexible)
      float pModInterval1(inout float p, float size, float start, float stop) {
        float halfsize = size*0.5;
        float c = floor((p + halfsize)/size);
        p = mod(p+halfsize, size) - halfsize;
        if (c > stop) { //yes, this might not be the best thing numerically.
          p += size*(c - stop);
          c = stop;
        }
        if (c <start) {
          p += size*(c - start);
          c = start;
        }
        return c;
      }

      // Repeat in two dimensions
      vec2 pMod2(inout vec2 p, vec2 size) {
        vec2 c = floor((p + size*0.5)/size);
        p = mod(p + size*0.5,size) - size*0.5;
        return c;
      }

      Model roundBox( vec3 p, vec3 dimensions, float radius )
      {
        vec3 pC = vec3(p.x, p.y, p.z);
        vec2 index = pMod2(pC.xz, vec2(8.0, 8.0));

        float r = 0.3;

        float g = 0.3;
        float b = 0.3;

        index.x /= 64.0;
        index.y /= 64.0;

        vec4 offset = texture2D(tex, index);


        pMod2(pC.xz, vec2(8.0, 8.0));
        float d = length(max(abs(pC)-dimensions,0.0))-radius;

        return Model(d, vec3(offset.x, offset.y, offset.z), 0.12);
      }

      // Plane with normal n (n is normalized) at some distance from the origin
      float fPlane(vec3 p, vec3 n, float distanceFromOrigin) {
        return dot(p, n) + distanceFromOrigin;
      }

      vec3 calcNormal( in vec3 pos ){
        vec3 eps = vec3( 0.001, 0.0, 0.0 );
        vec3 nor = vec3(
            roundBox(pos+eps.xyy, box, bevel).dist - roundBox(pos-eps.xyy, box, bevel).dist,
            roundBox(pos+eps.yxy, box, bevel).dist - roundBox(pos-eps.yxy, box, bevel).dist,
            roundBox(pos+eps.yyx, box, bevel).dist - roundBox(pos-eps.yyx, box, bevel).dist );
        return normalize(nor);
      }

      float fOpUnionRound(float a, float b, float r) {
        vec2 u = max(vec2(r - a,r - b), vec2(0.0));
        return max(r, min (a, b)) - length(u);
      }

      float fOpUnionSoft(float a, float b, float r) {
        float e = max(r - abs(a - b), 0.0);
        return min(a, b) - e*e*0.25/r;
      }

      // The "Chamfer" flavour makes a 45-degree chamfered edge (the diagonal of a square of size <r>):
      float fOpUnionChamfer(float a, float b, float r) {
        return min(min(a, b), (a - r + b)*sqrt(0.5));
      }

          
      Hit raymarch(CastRay castRay){

        float currentDist = INTERSECTION_PRECISION * 2.0;
        Model boxModel;
        Model planeModel;
        Model model;

        // camera and ray
        vec3 cPos  = cameraPos;
        vec3 cDir  = cameraDir;
        vec3 cSide = normalize( cross( cDir, vec3( 0.0, 1.0 ,0.0 ) ) );
        vec3 cUp   = normalize( cross( cSide, cDir ) );
        float targetDepth = 1.3;
        
        Ray ray = Ray(castRay.origin, castRay.direction, 0.);

        for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){
          if (currentDist < INTERSECTION_PRECISION || ray.len > MAX_TRACE_DISTANCE) {
              break;
          }
          vec3 rayVec = ray.origin + ray.direction * ray.len;
          boxModel = roundBox(rayVec, box, bevel);
          planeModel = Model(fPlane(rayVec, vec3(0.0, 1.0, 0.0), 1.0), vec3(0.3, 0.3, 0.3), 0.0);

          model = boxModel;
          if (planeModel.dist < boxModel.dist) {
            model = planeModel;
          }

          currentDist = min(boxModel.dist, planeModel.dist);
          ray.len += currentDist * FUDGE_FACTOR;
        }
        
        bool isBackground = false;
        vec3 pos = vec3(0);
        vec3 normal = vec3(0);
        vec3 color = vec3(0);
        
        if (ray.len > MAX_TRACE_DISTANCE) {
          isBackground = true;
        } else {
          pos = ray.origin + ray.direction * ray.len;
          normal = calcNormal(pos);
          if (planeModel.dist < boxModel.dist) {
            // normal = vec3(0, 1, 0);
            float test = abs(pos.x - 4.7);
            pModInterval1(test, 8.0, 0.0, 500.0);
            test = step(3.3, test);
            test = 1.0 - test;

            float test2 = abs(pos.z);
            pModInterval1(test2, 8.0, 0.0, 500.0);
            test2 = step(3.3, test2);
            test2 = 1.0 - test2;
            float intensity = test*test2;
            model.albedo.x = intensity*0.4;
            model.albedo.y = intensity*0.5;
            model.albedo.z = intensity*0.6;
          }
        }

        return Hit(ray, model, pos, isBackground, normal, color);
      }


      // --------------------------------------------------------
      // Rendering
      // --------------------------------------------------------

      void shadeSurface(inout Hit hit){
          
        vec3 color = BACKGROUND_COLOR;
        
        if (hit.isBackground) {
          hit.color = color;
          return;
        }

        vec3 ref = reflect(hit.ray.direction, hit.normal);

        #ifdef DEBUG
          color = hit.normal * 0.5 + 0.5;
        #else 
          color = doLighting(
            hit.model,
            hit.pos,
            hit.normal,
            ref,
            hit.ray.direction
          );
        #endif

        hit.color = color;
      }

      vec3 render(Hit hit){
          shadeSurface(hit);
        return hit.color;
      }

      // --------------------------------------------------------
      // Gamma
      // https://www.shadertoy.com/view/Xds3zN
      // --------------------------------------------------------

      const float GAMMA = 2.2;

      vec3 gamma(vec3 color, float g) {
          return pow(color, vec3(g));
      }

      vec3 linearToScreen(vec3 linearRGB) {
          return gamma(linearRGB, 1.0 / GAMMA);
      }

      void main()
      {
          vec2 p = (-iResolution.xy + 2.0*gl_FragCoord.xy)/iResolution.y;

          vec3 camTar = vec3( 0. , 0. , 0. );
          float camRoll = 0.;
          

          
          // create view ray
          vec3 rd = normalize( vec3(p.xy,2.0) ); // 2.0 is the lens length

          // camera and ray
          vec3 cPos  = cameraPos;
          vec3 cDir  = cameraDir;
          vec3 cSide = normalize( cross( cDir, vec3( 0.0, 1.0 ,0.0 ) ) );
          vec3 cUp   = normalize( cross( cSide, cDir ) );
          float targetDepth = 1.3;
          rd = normalize( cSide * p.x + cUp * p.y + cDir * targetDepth );
          
          Hit hit = raymarch(CastRay(cPos, rd));

          vec3 color = render(hit);
          
          #ifndef DEBUG
              color = linearToScreen(color);
          #endif

          gl_FragColor = vec4(color,1.0);
      }
    </script>

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style type="text/css">
      body {
        background-color: black;
        margin: 0;
        padding: 0;
      }
      canvas {
        display: block;
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        margin: auto;
      }
    </style>
  </head>
  <body>

    <script src="build/three.js"></script>
    <script src="lib/OrbitControls.js"></script>

    <script src="lib/stats.min.js"></script>

    

    <script id="vertex_shader" type="x-shader/x-vertex">
      attribute vec3 position;
      void main(void) {
        gl_Position = vec4(position, 1.0);
      }
    </script>

    <script>
      var camera, dummyCamera, scene, controls, renderer;
      var geometry, material, mesh;
      var mouse = new THREE.Vector2( 0.5, 0.5 );
      var canvas;
      var stats;
      var clock = new THREE.Clock();
      var texture;
      var gl;
      var ROW_SIZE = 32;
      var COL_SIZE = 32;
      var grid = [];

      init();
      render();

      function init() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera();
        dummyCamera = new THREE.Camera();
        camera.position.set(0, 100, 0);
        camera.lookAt( new THREE.Vector3( 0, 0, 0 ) );
        geometry = new THREE.PlaneBufferGeometry( 2.0, 2.0 );
        renderer = new THREE.WebGLRenderer();
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( 750, 750 );
        canvas = renderer.domElement;
        gl = renderer.getContext();


        var theOffsets = new Float32Array(4096);
        texture = textureFromFloats(gl, 32, 32, theOffsets);
        texture.needsUpdate = true;

        initGrid();
        updateDataTextureFromGrid(grid);

        material = new THREE.RawShaderMaterial( {
          uniforms: {
            iResolution: { value: new THREE.Vector2( canvas.width, canvas.height ) },
            cameraPos:  { value: camera.getWorldPosition() },
            cameraDir:  { value: camera.getWorldDirection() },
            offsets: {type: "fv", value: theOffsets},
            tex: {type: "t", value: texture}
          },
          vertexShader: document.getElementById( 'vertex_shader' ).textContent,
          fragmentShader: document.getElementById( 'fragment_shader' ).textContent
        } );

        mesh = new THREE.Mesh( geometry, material );
        scene.add( mesh );
        canvas.addEventListener( 'mousemove', onMouseMove );
        window.addEventListener( 'resize', onWindowResize );
        document.body.appendChild( canvas );
        controls = new THREE.OrbitControls( camera, canvas );
        controls.autoForward = false;
        controls.dragToLook = true;
        controls.rollSpeed = Math.PI / 22;
        controls.enableZoom = true;
        controls.movementSpeed = 50;
        stats = new Stats();
        document.body.appendChild( stats.dom );
      }

      function textureFromFloats(gl,width,height,float32Array) 
      {
        return new THREE.DataTexture(float32Array, width, height, THREE.RGBA, THREE.FloatType, THREE.UVMapping, THREE.RepeatWrapping, THREE.RepeatWrapping, THREE.NearestFilter, THREE.NearestFilter, 1);
      }

      function initGrid() {
        for (var i = 0; i < COL_SIZE; i++) {
          var row = [];

          for (var j = 0; j < ROW_SIZE; j++) {
            var val = Math.round(Math.random());
            row[j] = [val, val, val, val];
          }

          grid[i] = row;
        }
      }

      function updateDataTextureFromGrid(grid) {
        var vectorCount = texture.image.data.length / 4;
        for (var i = 0; i < texture.image.data.length; i+=4) {
          var row = Math.floor(i/4 / ROW_SIZE);
          var col = i/4 % ROW_SIZE;
          texture.image.data[i] = grid[row][col][0];
          texture.image.data[i+1] = grid[row][col][1];
          texture.image.data[i+2] = grid[row][col][2];
          texture.image.data[i+3] = grid[row][col][3];
        }
        texture.needsUpdate = true;
      }

      function render( timestamp ) {
        var delta = clock.getDelta();
        stats.begin();
        controls.update( delta );
        if ( camera.position.y < 0 ) camera.position.y = 0;
        material.uniforms.iResolution.value = new THREE.Vector2( canvas.width, canvas.height );
        material.uniforms.cameraPos.value = camera.getWorldPosition();
        material.uniforms.cameraDir.value = camera.getWorldDirection();

        updateDataTextureFromGrid(grid);

        renderer.render( scene, dummyCamera );
        stats.end();
        requestAnimationFrame( render );
      }

      function onMouseMove( e ) {
        mouse.x = e.offsetX / canvas.width;
        mouse.y = e.offsetY / canvas.height;
      }

      function onWindowResize( e ) {
        renderer.setSize( canvas.width, canvas.height );
      }
    </script>

  </body>
</html>