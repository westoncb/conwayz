<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link href="https://fonts.googleapis.com/css?family=Sahitya" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Open+Sans:400,700" rel="stylesheet">
    <link rel="stylesheet" href="style.css" type="text/css">
  </head>
  <body>

    <span class='title'><span class='big-c'>C</span>onwayz</span><span class='subtitle'>—"The vital, Conwaysian cellular automaton we all know and love."</span>
    <div class='main-container'>
      <div class='left-column side-column'>
        <div class='controls-section column-section'>
          <span class='minor-title'>Controls</span>
          <span class='controls-text'>
            <div class='controls-subsection'>
              <span class='bolded'>Zoom:</span>
              Mouse wheel or trackpad.
            </div>
            
            <div class='controls-subsection'>
              <span class='bolded'>Pan:</span>
              Right click and drag.
            </div>

            <div class='controls-subsection'>
              <span class='bolded'>Tilt camera:</span>
              Left click and drag.
            </div>

            <div class='controls-subsection'>
              <span class='bolded'>Toggle tiles:</span>
              Hold shift and click (or click and drag).
            </div>
          </span>
        </div>
        <hr>
        <div class='about-section column-section'>
          <span class='minor-title about-title'>About</span>
          <span class='about-text'>
            This program was created by <a href="http://westoncb.com">Weston Beecroft</a> mostly as a way to experiment
            with using <a href='http://9bitscience.blogspot.com/2013/07/raymarching-distance-fields_14.html'>raymarching</a> to do something practical. It has a pretty minimal feature set at the moment, but I may add to it in the near feature. You can contact me at <i>westoncb at Google's mail service</i>. The source is <a href='https://github.com/westoncb/conwayz'>available on Github</a>.
          </span>
        </div>
      </div>
      <div class='center-column'>
        <canvas id='canvas'></canvas>
        <div class='control-bar'>
          <div class='button-section'>
            <button class='play-btn control-btn btn btn-primary'><span class='glyphicon glyphicon-play'></span></button>
            <button class='pause-btn control-btn btn btn-primary'><span class='glyphicon glyphicon-pause'></span></button>
            <button class='back-btn control-btn btn btn-primary'><span class='glyphicon glyphicon glyphicon-step-backward'></span></button>
            <button class='forward-btn control-btn btn btn-primary'><span class='glyphicon glyphicon glyphicon-step-forward'></span></button>
            <button class='random-btn control-txt-btn btn btn-primary'><span class='small-btn-txt'>Random</span></button>
            <button class='clear-btn control-txt-btn btn btn-primary'><span class='small-btn-txt'>Clear</span></button>
          </div>
          <div class='speed-section'>
            <span>Speed:</span>
            <input type='range' class='speed-slider' min='0' max='100'>
          </div>
        </div>
      </div>
      <div class='right-column side-column'>
        <hr>
        <div class='config-description'>
          <p class='config-title minor-title'>No pattern selected</p>
          <p class='config-description-body'></p>
        </div>
      </div>
      
    </div>
    

    <script src="lib/three.js"></script>
    <script src="lib/OrbitControls.js"></script>

    <script src="lib/stats.min.js"></script>
    <script src="lib/jquery-2.2.1.min.js"></script>

    <!-- Boostrap CSS -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">

    <!-- Bootstrap JavaScript -->
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
  

    <script>
      var shadersToLoad = 2;
      var shaders = {vertex: '', fragment: ''};
      var camera, dummyCamera, scene, controls, renderer;
      var geometry, material, mesh;
      var mouse = new THREE.Vector2( 0.5, 0.5 );
      var canvas;
      var stats;
      var clock = new THREE.Clock();
      var texture;
      var gl;
      var ROW_SIZE = 256;
      var COL_SIZE = 256;
      var playing = false;
      var mouseButtonPressed = false;

      //Used for toggling cells in the scene by clicking on them
      //i.e. 'edit mode'
      var pixelData = new Float32Array(4);
      var hoverCell = new THREE.Vector2();
      var editModeActive = false;
      var pauseAtNextStep = false;
      var pauseDelayRemaining = 0;
      var cellsModifiedThisDrag = [];

      //A three dimensional array. Holds an array of 'row' arrays, each
      //element of which is a four component array carrying data for a
      //particular cell in the grid. The four components are:
      // 0) A one or zero indicating whether the cell is live or dead.
      // 1) A scale factor for resize animations during death/birth.
      // 2) A one if the cell's life/death state changed this turn; otherwise a one.
      // 3) Unused at the moment.
      var grid = [];

      var toggledCells = [];
      var timeSinceGameUpdate = 0;
      var stepTime = 500;
      var stepCompletion = 0;
      var configFileList = [];
      var mousePos = new THREE.Vector2();
      var renderTarget;

      init();
      update();

      function init() {
        setupConfigFileDropdown();


        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera();
        dummyCamera = new THREE.Camera();
        camera.position.set(0, 291.5, 0);
        camera.lookAt( new THREE.Vector3( 0, 0, 0 ) );
        geometry = new THREE.PlaneBufferGeometry( 2.0, 2.0 );
        canvas = document.getElementById("canvas");
        renderer = new THREE.WebGLRenderer({ canvas: canvas });
        renderer.setPixelRatio( window.devicePixelRatio );
        gl = renderer.getContext();

        var renderTargetParams = {
          minFilter:THREE.NearestFilter,
          stencilBuffer:false,
          depthBuffer:false,
          format: THREE.RGBAFormat,
          type: THREE.FloatType
        }
        renderTarget = new THREE.WebGLRenderTarget( 1, 1, renderTargetParams );

        loadShader('shaders/vertex.js', 'vertex');
        loadShader('shaders/fragment.js', 'fragment');

        window.addEventListener( 'resize', updateCenterColumnSize );
        controls = new THREE.OrbitControls( camera, canvas );
        controls.enableZoom = true;
        stats = new Stats();
        document.body.appendChild( stats.dom );

        

        updateCenterColumnSize();
        setUpSpeedSlider();
        setUpButtons();
        setUpEditModeEvents();
      }

      function setUpButtons() {
        $('.pause-btn').click(function(e) {
          playing = false;
        }); 
        $('.play-btn').click(function(e) {
          playing = true;
        });
      }

      function setUpSpeedSlider() {
        var speedSlider = $('.speed-slider');

        var updateStepTime = function(sliderVal) {
          var oldStepCompletionRatio = timeSinceGameUpdate / stepTime;

          //The slider component gives values between zero and 100, but we don't want it
          //to give totally linear values, so we map into two different ranges: when between
          //0 and 'threshold' the values are between max and firstRangeMax; when between 'threshold'
          // and 'sliderMax' the values are between firstRangeMax and min. The range endpoints are
          //reversed because we are changing 'stepTime', but from the user's perspective
          //the slider measures speed.
          var sliderMax = 100;
          var threshold = 30;
          var min = 25;
          var firstRangeMax = 700;
          var max = 3000;

          if (sliderVal > threshold) {
            var scale = 1 - ((sliderVal-threshold)/(sliderMax - threshold));
            stepTime = min + (firstRangeMax - min)*scale;
          } else {
            var scale = 1 - (sliderVal / threshold);
            stepTime = firstRangeMax + (max - firstRangeMax)*scale;
          }

          timeSinceGameUpdate = oldStepCompletionRatio * stepTime;
        }

        speedSlider.on('input', function(e) {
          var val = speedSlider.val();
          updateStepTime(val);
        });

        speedSlider.val(20)
        updateStepTime(speedSlider.val());
      }

      function setUpEditModeEvents() {
        $('canvas').mousemove(function(e) {
          mousePos.x = e.offsetX;
          mousePos.y = canvas.height - e.offsetY;

          if (editModeActive && mouseButtonPressed) {
            toggleCellWithCursor();
          }
        });

        $(document).keydown(function(e) {
          if (e.which === 16) {
            editModeActive = true;
            pauseAtNextStep = true;
            pauseDelayRemaining = stepTime - timeSinceGameUpdate;
            controls.enabled = false;
          }
        });

        $(document).keyup(function(e) {
          if (e.which === 16) {
            editModeActive = false;
            playing = true;
            pauseAtNextStep = false;
            controls.enabled = true;
          }
        });

        $('canvas').click(function(e) {
          if (editModeActive) {
            toggleCellWithCursor();
          }
        });

        $('canvas').mousedown(function(e) {
          mouseButtonPressed = true;
          cellsModifiedThisDrag = [];
        });

        $('canvas').mouseup(function(e) {
          mouseButtonPressed = false;
        });
      }

      function toggleCellWithCursor() {

        var row = (hoverCell.y + COL_SIZE/2);
        var col = hoverCell.x + ROW_SIZE/2;

        for (var i = 0; i < cellsModifiedThisDrag.length; i+=2) {
          var aRow = cellsModifiedThisDrag[i];
          var aCol = cellsModifiedThisDrag[i+1];

          if (row === aRow && col === aCol) {
            return;
          }
        }
        
        cellsModifiedThisDrag.push(row);
        cellsModifiedThisDrag.push(col);

        var cell = grid[row][col];
        

        if (cell[0] === 1) {
          cell[0] = 0;
          cell[1] = 0;
          cell[2] = 1;
          cell[3] = 0;
        } else {
          cell[0] = 1;
          cell[1] = 1;
          cell[2] = 0;
          cell[3] = 0;
        }

        updateDataTextureFromGrid(grid);
      }

      function shadersFinishedLoading() {
        initMaterial();
        initGrid();

        playing = true;
      }

      function initMaterial() {
        var theOffsets = new Float32Array(ROW_SIZE*COL_SIZE*4);
        texture = textureFromFloats(gl, ROW_SIZE, COL_SIZE, theOffsets);
        texture.needsUpdate = true;

        material = new THREE.RawShaderMaterial( {
          uniforms: {
            iResolution: { value: new THREE.Vector2( canvas.width, canvas.height ) },
            cameraPos:  { value: camera.getWorldPosition() },
            cameraDir:  { value: camera.getWorldDirection() },
            offsets: {type: "fv", value: theOffsets},
            tex: {type: "t", value: texture},
            stepCompletion: {value: stepCompletion},
            mousePos: {value: mousePos},
            pickPass: {value: false},
            hoverCell: {value: hoverCell}
          },
          vertexShader: shaders['vertex'],
          fragmentShader: shaders['fragment']
        } );

        mesh = new THREE.Mesh( geometry, material );
        scene.add( mesh );
      }

      function textureFromFloats(gl,width,height,float32Array) 
      {
        return new THREE.DataTexture(float32Array, width, height, THREE.RGBA, THREE.FloatType, THREE.UVMapping, THREE.RepeatWrapping, THREE.RepeatWrapping, THREE.NearestFilter, THREE.NearestFilter, 1);
      }

      function initGrid() {
        var configGrid = [];

        //Fill the config grid with random live and dead cells
        for (var i = 0; i < COL_SIZE; i++) {

          var row = [];
          for (var j = 0; j < ROW_SIZE; j++) {

            var val = Math.random();
            if (val < .61803) {
              val = 1;
            } else {
              val = 0;
            }

            row[j] = val;
          }

          configGrid[i] = row;
        }

        copyConfigGridIntoGrid(ROW_SIZE, COL_SIZE, configGrid, grid);
      }

      function stepConwaysGame(grid) {
        clearRecentlyToggledIndicators();
        toggledCells.length = 0;

        for (var i = 0; i < COL_SIZE; i++) {
          for (var j = 0; j < ROW_SIZE; j++) {

            var oldState = grid[i][j][0];
            var alive = oldState === 1;
            var neighborCount = liveNeighborCount(grid, i, j);

            var newState = newCellState(alive, neighborCount);
            
            //We don't immediately toggle cells because it would effect the application
            //of rules to other cells during this step of the game.
            if (newState !== oldState) {
              toggledCells.push(i);
              toggledCells.push(j);
            }
          }
        }

        //Actually toggle any cells that should be toggled now
        for (var i = 0; i < toggledCells.length; i+=2) {
          var row = toggledCells[i];
          var col = toggledCells[i+1];
          var cell = grid[row][col];

          if (cell[0] === 1) {
            newState = 0;
          } else {
            newState = 1;
          }
          cell[0] = newState;
          cell[2] = 1; //Indicates that its state changed this turn
        }
      }

      function newCellState(alive, neighborCount) {
        if (alive && neighborCount < 2) {
          return 0;
        } else if (alive && (neighborCount === 2 || neighborCount === 3)) {
          return 1;
        } else if (alive && neighborCount > 3) {
          return 0;
        } else if (!alive && neighborCount === 3) {
          return 1;
        } else {
          return 0;
        }
      }

      function liveNeighborCount(grid, row, col) {
        var leftNeighbor = 0;
        var rightNeighbor = 0;
        var topNeighbor = 0;
        var bottomNeighbor = 0;
        var ulNeighbor = 0;
        var llNeighbor = 0;
        var urNeighbor = 0;
        var lrNeighbor = 0;

        if (col > 0) {
          leftNeighbor = grid[row][col-1][0];
        }
        if (col < ROW_SIZE-1) {
          rightNeighbor = grid[row][col+1][0];
        }
        if (row > 0) {
          bottomNeighbor = grid[row-1][col][0];
        }
        if (row < COL_SIZE-1) {
          topNeighbor = grid[row+1][col][0];
        }
        if (row < COL_SIZE-1 && col > 0) {
          ulNeighbor = grid[row+1][col-1][0]; 
        }
        if (row > 0 && col > 0) {
          llNeighbor = grid[row-1][col-1][0]; 
        }
        if (row < COL_SIZE-1 && col < ROW_SIZE-1) {
          urNeighbor = grid[row+1][col+1][0]; 
        }
        if (row > 0 && col < ROW_SIZE-1) {
          lrNeighbor = grid[row-1][col+1][0]; 
        }

        return leftNeighbor + rightNeighbor + topNeighbor + bottomNeighbor +
               ulNeighbor + llNeighbor + urNeighbor + lrNeighbor;
      }

      function updateDataTextureFromGrid(grid) {
        var vectorCount = texture.image.data.length / 4;
        for (var i = 0; i < texture.image.data.length; i+=4) {

          //Each cell in the grid has four floats of data in the texture
          var cellIndex = i/4;
          var row = Math.floor(cellIndex / ROW_SIZE);
          var col = cellIndex % ROW_SIZE;
          texture.image.data[i] = grid[row][col][0];
          texture.image.data[i+1] = grid[row][col][1];
          texture.image.data[i+2] = grid[row][col][2];
          texture.image.data[i+3] = grid[row][col][3];
        }
        texture.needsUpdate = true;
      }

      function clearRecentlyToggledIndicators() {
        for (var i = 0; i < toggledCells.length; i+= 2) {
          var row = toggledCells[i];
          var col = toggledCells[i+1];

          grid[row][col][2] = 0;
        }
      }

      function sinEase(t, start, end) {
        return -(end-start)/2 * (Math.cos(Math.PI*t) - 1) + start;
      }

      function setupConfigFileDropdown() {
        $.ajax({
          //This will retrieve the contents of the folder if the folder is configured as 'browsable'
          url: './configs',
          success: function (data) {
            $(data).find("a:contains(" + ".l" + ")").each(function() {
                configFileList.push($(this).attr('href'));
            });

            var dropdownContainer = $('.right-column');
            var dropdown = $('<div class="dropdown"></div>');
            var menu = $('<ul class="dropdown-menu"></ul>');
            var index = 0;
            configFileList.forEach(function(path) {
              var fileName = fileNameOnly(path);
              menu.append('<li><a href="#" class="menu-item" id='+ index +'>' + fileName + '</a></li>');
              index++;
            });

            dropdown.append('<button class="configs-btn btn btn-primary dropdown-toggle" type="button" data-' +
              'toggle="dropdown">Patterns <span class="caret"></span></button>');
            dropdown.append(menu);
            dropdownContainer.prepend(dropdown);

            $('.menu-item').click(function(e) {
              var index = Number(e.target.id);
              var path = configFileList[index];
              readTextFile(path, loadNewConwaysConfig);
              $('.config-title').text(fileNameOnly(path));
            });
          }
        });
      }

      function fileNameOnly(path) {
        return path.substring(path.lastIndexOf('/')+1);
      }

      function loadNewConwaysConfig(text) {
        var result = parseConwaysConfig(text);

        var comments = result[0];
        var dimensions = result[1];
        var configGrid = result[2];

        var configWidth = dimensions[0];
        var configHeight = dimensions[1];

        copyConfigGridIntoGrid(configWidth, configHeight, configGrid, grid);

        displayComments(comments);
      }

      function displayComments(comments) {
        var commentText = "";

        comments.forEach(function(comment, i) {
          var prefix = '';
          if (i !== 0) {
            prefix = '<br>'
          }
          commentText += prefix + comment.substring(2);
        });

        $('.config-description-body').html(commentText);

        //The column displaying comment text may resize here, so
        //we need to update the size of the center column too
        updateCenterColumnSize();
      }

      function copyConfigGridIntoGrid(configWidth, configHeight, configGrid, grid) {
        //Used to center the config grid over our grid (since they may be different sizes)
        var xOffset = Math.floor((ROW_SIZE - configWidth)/2);
        var yOffset = Math.floor((COL_SIZE - configHeight)/2);

        for (var i = 0; i < COL_SIZE; i++) {
          var row = [];

          var configRowIndex = i - yOffset;
          var configRow = null;

          if (configRowIndex >= 0 && configRowIndex < configHeight) {
            configRow = configGrid[configRowIndex];
          }

          for (var j = 0; j < ROW_SIZE; j++) {

            var configIndex = j - xOffset;
            var val = 0;

            if (configRow != null && configIndex >= 0 && configIndex < configWidth) {
              val = configRow[configIndex];
            }

            //Each cell in the grid holds an arry of data.
            row[j] = [val,val,0,0];
          }

          grid[i] = row;
        }

        updateDataTextureFromGrid(grid);
      }

      //This is for 'dbLife (*.L)' files, as described here: http://psoup.math.wisc.edu/mcell/ca_files_formats.html
      function parseConwaysConfig(text) {
        var lines = text.match(/[^\r\n]+/g);
        var comments = [];
        var dimensions = [];
        var gridText = "";
        var gridData;
        
        lines.forEach(function(line) {
          if (line.startsWith('#')) { //comments
            comments.push(line);
          } else if (line.toLowerCase().startsWith("x")) { //dimensions

            var noWhiteSpaceLine = line.replace(/\s/g,'');
            var xAndY = noWhiteSpaceLine.split(",");
            var x = xAndY[0].split("=")[1];
            var y = xAndY[1].split("=")[1];
            dimensions.push(Number(x));
            dimensions.push(Number(y));

          } else { //grid data (actual info about whether cells are live or dead)
            gridText += line;
          }
        });

        gridData = parseGridText(gridText, dimensions);

        return [comments, dimensions, gridData];
      }

      function parseGridText(text, dimensions) {
        var rows = text.split("$");
        var width = dimensions[0];
        var height = dimensions[1];
        var grid = new Array(height);
        for (var i = 0; i < grid.length; i++) {
          grid[i] = new Array(width);
        }

        rows.forEach(function(row, j) {
          var inNumChunk = false;
          var inBOChunk = false;
          var numChunk = "";
          var boChunk = "";
          var chunks = [];

          for (var i = 0; i < row.length; i++) {
            var char = row[i];

            if (char === 'o' || char === 'b') { //Live cell or dead cell
              if (inBOChunk) {
                boChunk += char;
              } else {
                boChunk = char;
              }

              inBOChunk = true;

              if (inNumChunk) {
                chunks.push(Number(numChunk));
                inNumChunk = false;
              }

              if (i === row.length-1 || row[i+1] === "!") {
                chunks.push(boChunk);
              }
            } else if (!isNaN(char)) { //It's a number

              if (inNumChunk) {
                numChunk += char;
              } else {
                numChunk = char;
              }

              inNumChunk = true;

              if (inBOChunk) {
                chunks.push(boChunk);
                inBOChunk = false;
              }

              if (i === row.length-1 || row[i+1] === "!") {
                chunks.push(numChunk);
              }
            } else if (char !== "!") { // "!" indicates the end of the data
              console.log("ERROR: unexpected character in config file grid data.");
            }
          }

          fillRow(grid[j], chunks, width);
          
        });

        
        //Add empty rows for the difference between specified
        //grid height and the actual data provided
        for (var i = rows.length; i < height; i++) {
          fillRow(grid[i], [], width);
        }

        return grid;
      }

      function fillRow(row, chunks, rowSize) {
        var rowIndex = 0;
        var tagCount = 1;

        chunks.forEach(function(chunk) {

          if (!isNaN(chunk)) { //It's a number
            tagCount = chunk;
          } else {
            for (var i = 0; i < chunk.length; i++) {
              var char = chunk.charAt(i);

              //Convert b and o to 0 and 1
              if (char === 'b') {
                char = 0;
              } else if (char === 'o') {
                char = 1;
              }

              if (i === 0) {
                for (var j = 0; j < tagCount; j++) {
                  row[rowIndex] = char;
                  rowIndex++;
                }
              } else {
                row[rowIndex] = char;
                rowIndex++;
              }
            }
            tagCount = 1;
          }
        });

        //Fill in the ends of rows with zeros
        for (var i = rowIndex; i < rowSize; i++) {
          row[i] = 0;
        }
      }

      function readTextFile(file, completion)
      {
        var rawFile = new XMLHttpRequest();
        rawFile.open("GET", file, true);
        rawFile.onreadystatechange = function ()
        {
          if(rawFile.readyState === 4)
          {
            if(rawFile.status === 200 || rawFile.status == 0)
            {
              var allText = rawFile.responseText;

              completion(allText);
            }
          }
        }
        rawFile.send(null);
      }

      function update(timestamp) {
        stats.begin();

        var delta = clock.getDelta();
        var deltaMillis = delta*1000;

        if (pauseAtNextStep) {
          pauseDelayRemaining -= deltaMillis;

          if (pauseDelayRemaining <= 0) {
            pauseAtNextStep = false;
            playing = false;
          }
        }
        
        if (playing) {
          updateGame(deltaMillis);
        }

        controls.update( delta );
        if ( camera.position.y < 0 ) camera.position.y = 0;
        if (material) {
          material.uniforms.iResolution.value = new THREE.Vector2( canvas.width, canvas.height );
          material.uniforms.cameraPos.value = camera.getWorldPosition();
          material.uniforms.cameraDir.value = camera.getWorldDirection();
          material.uniforms.stepCompletion.value = stepCompletion;
          material.uniforms.mousePos.value = mousePos;
        }

        render (delta)
      }

      function render(delta) {
        if (material) {

          //In edit mode we make two rendering passes. The first one renders
          //the scene as usual, the second renders to a one pixel texture
          //which, after the pass, will contain the cell index which the
          //cursor is presently hovering over. The same shader is used,
          //but the uniform 'pickPass' causes it to behave differently
          //on this other pass.
          if (editModeActive) {
            material.uniforms.pickPass.value = false;
            renderer.render(scene, dummyCamera);
            material.uniforms.pickPass.value = true;
            renderer.render(scene, dummyCamera, renderTarget);

            gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.FLOAT, pixelData);
            hoverCell.x = pixelData[0];
            hoverCell.y = pixelData[1];
            material.uniforms.hoverCell.value = hoverCell;
          } else {
            hoverCell.x = -99999;
            hoverCell.y = -99999;
            material.uniforms.pickPass.value = false;
            material.uniforms.hoverCell.value = hoverCell;
            renderer.render(scene, dummyCamera);
          }
        }

        stats.end();
        requestAnimationFrame( update );
      }

      function updateGame(deltaMillis) {
        timeSinceGameUpdate += deltaMillis;

        if (timeSinceGameUpdate > stepTime) {
          stepConwaysGame(grid);
          timeSinceGameUpdate = 0;
        }

        stepCompletion = sinEase(timeSinceGameUpdate / stepTime, 0, 1);

        updateDataTextureFromGrid(grid);

        if (toggledCells !== undefined) {
          for (var i = 0; i < toggledCells.length; i+= 2) {
            var row = toggledCells[i];
            var col = toggledCells[i+1];

            var target = grid[row][col][0];
            var initial = target === 1 ? 0 : 1;
            var completionRatio = (timeSinceGameUpdate / stepTime);
            grid[row][col][1] = initial + (target - initial)*stepCompletion;

            grid[row][col][2] = 1;
          }
        }
      }

      var timeoutEvent;

      function updateCenterColumnSize(e) {
        doResize();

        clearTimeout(timeoutEvent);
        timeoutEvent = setTimeout(doResize, 500);
      }

      function doResize() {
        var win = $(window);
        var centerColumn = $('.center-column');
        var canvas = $('#canvas');
        var controlBar = $('.control-bar');

        var controlBarHeight = 40;
        var freeVerticalSpace = 120;
        var columnHeight = win.height() - freeVerticalSpace;
        var width = centerColumn.width();
        var canvasHeight = columnHeight - controlBarHeight;

        centerColumn.css('height', columnHeight);
        canvas.css('height', canvasHeight)
        canvas.css('width', width);
        controlBar.css('height', controlBarHeight);
        controlBar.css('width', width);

        //There is more complexity in this resize function than it seems like
        //needs to be, because this 'setSize' function must be called in order to
        //update properties of the threejs renderer—but it also updates the canvas
        //component size (which we would prefer to be resized automatically through CSS).
        //Flexbox is resizing the canvas' container, and we want the width of the canvas
        //to match the container width—but there is some timing issue or something with
        //retreiving the width (which is why we use a delay in 'updateCenterColumnSize'). The most
        //this has done is mitigate the issue; the layout remains imperfect.
        renderer.setSize(width, canvasHeight);
      }

      function loadShader(src, type) {
        $.ajax({
            url: src,
            dataType: 'text',
            context: {
                type: type
            },
            complete: processShader
        });
      }

      function processShader(jqXHR, textStatus, x, y) {
        shaders[this.type] = jqXHR.responseText;
        shadersToLoad--;

        if (shadersToLoad === 0) {
          shadersFinishedLoading();
        }
      }
    </script>

  </body>
</html>